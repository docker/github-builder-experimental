name: build

on:
  workflow_call:
    inputs:
      set-meta-annotations:
        type: boolean
        description: "Set metadata-action annotations"
        required: false
        default: false
      set-meta-labels:
        type: boolean
        description: "Set metadata-action labels"
        required: false
        default: false
      meta-image:
        type: string
        description: "Image to use as base name for tags"
        required: false
      meta-tags:
        type: string
        description: "List of tags as key-value pair attributes"
        required: false
      meta-flavor:
        type: string
        description: "Flavors to apply"
        required: false
      meta-labels:
        type: string
        description: "List of custom labels"
        required: false
      meta-annotations:
        type: string
        description: "List of custom annotations"
        required: false
      build-args:
        type: string
        description: "List of build-time variables"
        required: false
      build-output:
        type: string
        description: "Build output destination (one of cacheonly, registry, local)"
        default: 'cacheonly'
        required: false
      build-platforms:
        type: string
        description: "List of target platforms to build"
        required: false
      build-sbom:
        type: string
        description: "Generate SBOM attestation for the build (shorthand for --attest=type=sbom)"
        required: false
    secrets:
      registry-auths:
        description: "Registry authentication details as YAML objects"
        required: false
      github-token:
        description: "GitHub Token used to authenticate against a repository for Git context"
        required: false

env:
  LOCAL_OUTPUT_DIR: /tmp/buildx-output

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # needed for pushing the images to GitHub Packages
      id-token: write # needed for signing the images with GitHub OIDC Token
      attestations: write # needed for signing the local artifacts
    steps:
      -
        name: Prepare
        id: prepare
        uses: actions/github-script@v7
        env:
          INPUT_LOCAL-OUTPUT-DIR: ${{ env.LOCAL_OUTPUT_DIR }}
          INPUT_META-IMAGE: ${{ inputs.meta-image }}
          INPUT_BUILD-OUTPUT: ${{ inputs.build-output }}
        with:
          script: |
            const localOutputDir = core.getInput('local-output-dir');
            const metaImage = core.getMultilineInput('meta-image');
            const buildOutput = core.getInput('build-output');
            
            switch (buildOutput) {
              case 'cacheonly':
                core.setOutput('output', 'type=cacheonly');
                break;
              case 'registry':
                if (metaImage.length == 0) {
                  core.setFailed('meta-image is required when build-output is registry');
                } else if (metaImage.length > 1) {
                  core.setFailed('Only one meta-image is supported');
                }
                core.setOutput('output', `type=registry,"name=${metaImage[0]}",oci-artifact=true,push-by-digest=true,name-canonical=true`);
                break;
              case 'local':
                core.setOutput('output', `type=local,dest=${localOutputDir}`);
                break;
              default:
                core.setFailed(`Invalid build-output: ${buildOutput}`);
            }
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: https://github.com/docker/buildx.git#refs/pull/3453/merge
          buildkitd-flags: --debug
      -
        name: Login to registry
        if: ${{ inputs.build-output == 'registry' }}
        # TODO: switch to docker/login-action when OIDC is supported
        uses: crazy-max/docker-login-action@dockerhub-oidc
        with:
          registry-auth: ${{ secrets.registry-auths }}
      -
        name: Docker meta
        id: meta
        if: ${{ inputs.build-output == 'registry' }}
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.meta-image }}
          tags: ${{ inputs.meta-tags }}
          flavor: ${{ inputs.meta-flavor }}
          labels: ${{ inputs.meta-labels }}
          annotations: ${{ inputs.meta-annotations }}
      -
        name: Build
        id: build
        uses: docker/build-push-action@v6
        with:
          build-args: ${{ inputs.build-args }}
          platforms: ${{ inputs.build-platforms }}
          outputs: ${{ steps.prepare.outputs.output }}
          provenance: mode=max,version=v1
          sbom: ${{ inputs.build-sbom }}
          labels: ${{ inputs.set-meta-labels && steps.meta.outputs.labels || '' }}
          annotations: ${{ inputs.set-meta-annotations && steps.meta.outputs.annotations || '' }}
          github-token: ${{ secrets.github-token || github.token }}
        env:
          BUILDKIT_MULTI_PLATFORM: 1
      -
        name: List output
        if: ${{ inputs.build-output == 'local' }}
        run: |
          tree -nh ${{ env.LOCAL_OUTPUT_DIR }}
#      -
#        name: Install cosign
#        uses: sigstore/cosign-installer@d58896d6a1865668819e1d91763c7751a165e159 # v3.9.2
      -
        name: Checkout cosign
        uses: actions/checkout@v5
        with:
          repository: crazy-max/cosign
          ref: 3.0.2-fix-oci-manifest
          path: cosign-tmp
      -
        name: Set up Go for cosign
        uses: actions/setup-go@v6
        with:
          go-version: "1.25.1" # https://github.com/sigstore/cosign/blob/2ec2734e8407ea90ea36103a882b3be2195567eb/Dockerfile#L18
          cache-dependency-path: cosign-tmp/go.sum
      -
        name: Build and install cosign
        working-directory: cosign-tmp
        run: |
          make install
          cosign version
      -
        name: Get attestations manifest digest
        id: attest
        if: ${{ inputs.build-output == 'registry' }}
        uses: actions/github-script@v7
        env:
          INPUT_IMAGE-NAME: ${{ inputs.meta-image }}
          INPUT_IMAGE-DIGEST: ${{ steps.build.outputs.digest }}
        with:
          script: |
            let manifest = {};
            await core.group(`Get manifest`, async () => {
              await exec.getExecOutput('docker', ['buildx', 'imagetools', 'inspect',
                `${core.getInput('image-name')}@${core.getInput('image-digest')}`,
                '--format', '{{json .Manifest}}'
              ], {
                ignoreReturnCode: true
              }).then(res => {
                if (res.stderr.length > 0 && res.exitCode != 0) {
                  throw new Error(res.stderr);
                }
                manifest = JSON.parse(res.stdout.trim());
              });
            });
            await core.group(`Get attestations manifest digest`, async () => {
              const attestationDigests = manifest.manifests.filter(m => m.annotations && m.annotations['vnd.docker.reference.type'] === 'attestation-manifest').map(m => m.digest);
              core.info(JSON.stringify(attestationDigests, null, 2));
              core.setOutput('digests', attestationDigests.join('\n'));
            });
      -
        name: Signing attestations (registry)
        if: ${{ inputs.build-output == 'registry' }}
        uses: actions/github-script@v7
        env:
          INPUT_TAGS: ${{ steps.meta.outputs.tags }}
          INPUT_DIGESTS: ${{ steps.attest.outputs.digests }}
          COSIGN_EXPERIMENTAL: 1
        with:
          script: |
            const tags = core.getMultilineInput('tags');
            const digests = core.getMultilineInput('digests');
            const images = [];
            for (const tag of tags) {
              for (const digest of digests) {
                images.push(`${tag}@${digest}`);
              }
            }
            await exec.getExecOutput('cosign', ['-d', 'sign', '--yes',
              '--oidc-provider', 'github-actions',
              '--oidc-issuer', 'https://token.actions.githubusercontent.com',
              '--registry-referrers-mode', 'oci-1-1',
              '--annotations', `vnd.docker.reference.origin=docker.io/github-builder/${context.repo.owner}/${context.repo.repo}`,
              '--new-bundle-format', 'true',
              '--use-signing-config', 'true',
              ...images
            ], {
              ignoreReturnCode: true
            }).then(res => {
              if (res.stderr.length > 0 && res.exitCode != 0) {
                throw new Error(res.stderr);
              }
            });
      -
        name: Signing artifacts amd64 (local)
        if: ${{ inputs.build-output == 'local' }}
        uses: crazy-max/actions-attest@skip-write
        id: attest_amd64
        with:
          subject-path: "${{ env.LOCAL_OUTPUT_DIR }}/linux_amd64/**/*"
          predicate-type: "https://slsa.dev/provenance/v1"
          predicate-path: "${{ env.LOCAL_OUTPUT_DIR }}/linux_amd64/provenance.json"
          skip-write: true
      -
        name: Signing artifacts arm64 (local)
        if: ${{ inputs.build-output == 'local' }}
        uses: crazy-max/actions-attest@skip-write
        id: attest_arm64
        with:
          subject-path: "${{ env.LOCAL_OUTPUT_DIR }}/linux_arm64/**/*"
          predicate-type: "https://slsa.dev/provenance/v1"
          predicate-path: "${{ env.LOCAL_OUTPUT_DIR }}/linux_arm64/provenance.json"
          skip-write: true
      -
        name: Verify signatures (registry)
        if: ${{ inputs.build-output == 'registry' }}
        uses: actions/github-script@v7
        env:
          INPUT_IMAGE-NAME: ${{ inputs.meta-image }}
          INPUT_DIGESTS: ${{ steps.attest.outputs.digests }}
          COSIGN_EXPERIMENTAL: 1
        with:
          script: |
            const maxRetries = 20;
            const digests = core.getMultilineInput('digests');
            for (const digest of digests) {
              const manifest = `${core.getInput('image-name')}@${digest}`;
              let attempt = 1;
              let res;
              let retry = true;
              do {
                core.info(`#####`);
                core.info(`##### Verifying ${manifest} (attempt ${attempt}/${maxRetries})`);
                core.info(`#####`);
                await new Promise(resolve => setTimeout(resolve, 1000));
                res = await exec.getExecOutput('cosign', [
                  '-d', 'verify',
                  '--experimental-oci11',
                  '--certificate-identity-regexp', `^https://github.com/docker/github-builder-experimental/.github/workflows/build.yml.*$`,
                  '--certificate-oidc-issuer', 'https://token.actions.githubusercontent.com',
                  '--annotations', `vnd.docker.reference.origin=docker.io/github-builder/${context.repo.owner}/${context.repo.repo}`,
                  manifest
                ], {
                  ignoreReturnCode: true
                });
                if (res.exitCode != 10) retry = false;
                attempt++;
              } while (retry && attempt < maxRetries);
              if (res.exitCode != 0) {
                core.setFailed(`Signature verification failed for ${manifest}`);
              }
            }
      -
        name: Verify signatures (local)
        if: ${{ inputs.build-output == 'local' }}
        uses: actions/github-script@v7
        env:
          INPUT_LOCAL-OUTPUT-DIR: ${{ env.LOCAL_OUTPUT_DIR }}
          INPUT_BUNDLE-PATH-AMD64: ${{ steps.attest_amd64.outputs.bundle-path }}
          INPUT_BUNDLE-PATH-ARM64: ${{ steps.attest_arm64.outputs.bundle-path }}
          COSIGN_EXPERIMENTAL: 1
        with:
          script: |
            const fs = require('fs');
            const inpLocalOutputDir = core.getInput('local-output-dir');
            const inpBundlePathAmd64 = core.getInput('bundle-path-amd64');
            const inpBundlePathArm64 = core.getInput('bundle-path-arm64');
            fs.copyFileSync(inpBundlePathAmd64,  `${inpLocalOutputDir}/linux_amd64/provenance.sigstore.json`);
            fs.copyFileSync(inpBundlePathArm64,  `${inpLocalOutputDir}/linux_arm64/provenance.sigstore.json`);
      -
        name: Create manifest
        if: ${{ inputs.build-output == 'registry' }}
        uses: actions/github-script@v7
        env:
          INPUT_TAGS: ${{ steps.meta.outputs.tags }}
          INPUT_IMAGE-DIGEST: ${{ steps.build.outputs.digest }}
        with:
          script: |
            let createArgs = ['buildx', 'imagetools', 'create'];
            for (const tag of core.getMultilineInput('tags')) {
              createArgs.push('-t', tag);
            }
            createArgs.push(core.getInput('image-digest'));
            await exec.getExecOutput('docker', createArgs, {
              ignoreReturnCode: true
            }).then(res => {
              if (res.stderr.length > 0 && res.exitCode != 0) {
                throw new Error(res.stderr);
              }
            });
      -
        name: List output
        if: ${{ inputs.build-output == 'local' }}
        run: |
          tree -nh ${{ env.LOCAL_OUTPUT_DIR }}
      -
        name: Upload artifact
        if: ${{ inputs.build-output == 'local' }}
        uses: actions/upload-artifact@v4
        with:
          name: docker-github-builder-output
          path: ${{ env.LOCAL_OUTPUT_DIR }}
          if-no-files-found: error
